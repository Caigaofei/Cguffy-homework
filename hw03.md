# 我的第三次作业
## 一、Write out variables  x, y and z in binary code 
1. int8_t x = 67 : 01000001 ;<br>
int8_t y = -7 : 11111001 ;<br>
int8_t z = y - x : 01001000 ;<br>
2) int8_t x = 0xd3 ：  ***溢出错误*** ;<br>

3. uint8_t = 0xd3 ： 11010011 ;<br>

4. int8_t x = 127 : 01111111 ;<br>
int8_t y = -7 : 11111001 ;<br>
int8_t z = y – x : ***溢出错误*** ;<br>
5. float x = 1.125 : 1.001 ; <br>
6. float x = 23.0 : 10111.0 ;<br>
7. float x = 0.45 : 0.11100(出现 ***精度误差*** ，以1100循环) ;<br>
## 二、维基百科
Word|Explanation
---|--|---
Method of <br>complements|In mathematics and computing, the method of complements is a technique used to subtract one number from another using only addition of positive numbers.
Byte|The byte is a unit of digital information that most commonly consists of eight bits, representing a binary number.
Integer <br>(computer <br>science)|In computer science, an integer is a datum of integral data type, a data type that represents some range of mathematical integers.
Floating <br>point|Floating Point is an album by John McLaughlin, released in 2008 through the record label Abstract Logix.
NaN|In computing, NaN, standing for not a number, is a numeric data type value representing an undefined or unrepresentable value, especially in floating-point calculations. 
NaN<br>(自主解释)|NaN's meaning is "Not a number". In JS, if try to turn String or Boolean to a number, it will return a result which is "NaN".

## 三、证明补码机制
Negative(I) = 2<sup>k</sup> - 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=[(2<sup>k</sup> - 1) -  I] + 1<br>
∵一个字节八位数最多可表示到2<sup>8</sup>-1，然而若直接用公式<br>**Negative(I) = 2<sup>k</sup> - 1**<br>
八位数无法表示2<sup>k</sup><br>
∴需先进行 **2<sup>k</sup> - 1** 的处理，而这表示的就是二进制的 **11111111**<br>
然后再使用 **11111111** 减去 **I**，而这就是将原码反过来能得到反码的原因<br>之后再把 1 **加回去**，表示的就是 I 的*负数*

## 四、描述变量
1) Int8_t x = - 017; 请用八进制描述变量 **x**。<br>
**答案：** 361.<br><br><br>
2) int8_t  x = -0x1f;  int y = x;  请用16进制描述变量 **x**和 **y**，并说明int y = x 的计算过程。<br>
**答案：** x = y = 0xe1.<br>
int y为32位（或者64位）<br>
x = 11100001（二进制8位）<br>
y为了补齐前面的三个字节的数字，又因为 **x**为**负数**<br>
∴ y = (11111111)(11111111)(11111111)(11100001)<br><br>
**证明：**<br>
1、正数：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;高位补零不会影响该数的值；<br>
2、负数：<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设一个数 x = 00011111, y = Negative(x) (用32位表示)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当要将其换化为32位时，最高位变为最左边的数，即上方的 y的表示中的第一个字节中的第一个1.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若要最后一个字节的数字不发生改变，则**前面三个字节**所代表的数值需要为 **0**.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然而因为 x 的值是一个**负数**，所以要取补码的话就需要将前三个字节中的 0 转为 1.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最终 x 的32位表示:<br>(00000000)(00000000)(00000000)(00011111)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;转变为负数 y 便为:<br>(11111111)(11111111)(11111111)(11100001).